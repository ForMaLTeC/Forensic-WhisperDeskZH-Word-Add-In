name: Build and Publish VSTO Add-in

on:
  push:
    branches: [ main, develop]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  SOLUTION_PATH: './ForensicWhisperDeskZH.sln'
  PROJECT_PATH: './ForensicWhisperDeskZH/ForensicWhisperDeskZH.csproj'
  MODEL_DOWNLOADER_PATH: './ModelDownloader/ModelDownloader.csproj'
  BUILD_CONFIGURATION: 'Release'
  BUILD_PLATFORM: 'Any CPU'
  PUBLISH_URL: 'https://your-domain.com/vsto/'
  APPLICATION_NAME: 'ForensicWhisperDeskZH'
  # Define which models to download for production
  WHISPER_MODELS: 'base,large'

jobs:
  build-model-download:
    runs-on: windows-latest
    
    permissions:
        contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup GitVersion
      uses: gittools/actions/gitversion/setup@v0.9.15
      with:
        versionSpec: '5.x'
        
    - name: Determine Version
      id: gitversion
      uses: gittools/actions/gitversion/execute@v0.9.15
      
    - name: Setup .NET Framework
      uses: microsoft/setup-msbuild@v2
      
    - name: Setup .NET 8
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0'
        
    - name: Setup NuGet
      uses: nuget/setup-nuget@v2
      with:
        nuget-version: 'latest'
      
    - name: Restore packages for ModelDownloader
      run: dotnet restore ${{ env.MODEL_DOWNLOADER_PATH }}
      
    # Build and run ModelDownloader before main build
    - name: Build ModelDownloader (without signing)
      run: dotnet build ${{ env.MODEL_DOWNLOADER_PATH }} --configuration Release --no-restore /p:SignAssembly=false /p:SignManifests=false
      
    - name: Download Whisper Models using ModelDownloader
  
      run: |
        Write-Host "=== Starting Whisper Model Download Process ==="
        
        # Create Models directory in the main project
        $modelsDir = "ForensicWhisperDeskZH\Models"
        New-Item -ItemType Directory -Force -Path $modelsDir
        Write-Host "Created models directory: $modelsDir"
        
        # Parse the models from environment variable - keep as comma-separated
        $modelsString = "${{ env.WHISPER_MODELS }}"
        Write-Host "Models to download: $modelsString"
        
        try {
          # Run the ModelDownloader
          $downloaderPath = "ModelDownloader\bin\Release\net8.0\ModelDownloader.exe"
          
          if (Test-Path $downloaderPath) {
            Write-Host "Running ModelDownloader..."
            # Pass the comma-separated string directly to --models
            & $downloaderPath --models $modelsString --target $modelsDir
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "ModelDownloader completed successfully"
            } else {
              throw "ModelDownloader failed with exit code $LASTEXITCODE"
            }
          } else {
            throw "ModelDownloader executable not found at $downloaderPath"
          }
        } catch {
          Write-Host "ModelDownloader failed: $($_.Exception.Message)"
          Write-Host "Falling back to direct download method..."
          
          # Fallback to direct download
          $models = "${{ env.WHISPER_MODELS }}" -split ","
          $baseUrl = "https://huggingface.co/sandrohanea/whisper.net/resolve/v3/classic"
          
          foreach ($model in $models) {
            $model = $model.Trim()
            $fileName = "ggml-$model.bin"
            $filePath = "$modelsDir\$fileName"
            $downloadUrl = "$baseUrl/$fileName"
            
            if (Test-Path $filePath) {
              $fileSize = (Get-Item $filePath).Length / 1MB
              Write-Host "Model $model already exists ($([math]::Round($fileSize, 1)) MB) - skipping"
              continue
            }
            
            Write-Host "⬇️  Downloading $model model from $downloadUrl..."
            try {
              Invoke-WebRequest -Uri $downloadUrl -OutFile $filePath -UseBasicParsing
              $fileSize = (Get-Item $filePath).Length / 1MB
              Write-Host "Successfully downloaded $model model ($([math]::Round($fileSize, 1)) MB)"
            } catch {
              Write-Host "Failed to download $model model: $($_.Exception.Message)"
              exit 1
            }
          }
        }
        
        # Verify downloaded models
        Write-Host "Verifying downloaded models:"
        if (Test-Path $modelsDir) {
          Get-ChildItem -Path $modelsDir -Filter "*.bin" | ForEach-Object {
            $sizeInMB = $_.Length / 1MB
            Write-Host "    $($_.Name) - $([math]::Round($sizeInMB, 1)) MB"
          }
        }
        
        Write-Host "Whisper model download process completed successfully!"

    
    # Install Code Signing Certificate
    - name: Install Code Signing Certificate
      run: |
        # Decode certificate from base64
        $certBytes = [System.Convert]::FromBase64String("${{ secrets.SIGNING_CERTIFICATE }}")
        $certPath = "$env:TEMP\ForensicWhisperDeskZH.pfx"
        [System.IO.File]::WriteAllBytes($certPath, $certBytes)
        
        # Import certificate to Personal store
        $securePassword = ConvertTo-SecureString "${{ secrets.CERTIFICATE_PASSWORD }}" -AsPlainText -Force
        Import-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePassword
        
        # Clean up certificate file
        Remove-Item $certPath -Force
        
        Write-Host "Certificate installed successfully"

    - name: Restore NuGet packages for solution
      run: nuget restore ${{ env.SOLUTION_PATH }}

    - name: Build Word Add-In
      run: msbuild ${{ env.SOLUTION_PATH }} /t:publish /p:Configuration=Release /p:PublishDir=.\publish\ /p:PublishUrl=.\publish\

          # Debug step to find the actual output paths
    - name: List build output directories
      run: |
        Write-Host "=== Build Output Investigation ==="
        
        # List all directories that might contain build outputs
        $searchPaths = @(
          "ForensicWhisperDeskZH\bin\Release",
          "ForensicWhisperDeskZH\bin",
          "ForensicWhisperDeskZH\publish",
          "bin\Release",
          "publish"
        )
        
        foreach ($path in $searchPaths) {
          if (Test-Path $path) {
            Write-Host "📁 Found directory: $path"
            Get-ChildItem -Path $path -Recurse | ForEach-Object {
              $relativePath = $_.FullName.Substring((Get-Location).Path.Length + 1)
              $size = if ($_.PSIsContainer) { "DIR" } else { "$([math]::Round($_.Length / 1KB, 1)) KB" }
              Write-Host "    $relativePath - $size"
            }
            Write-Host ""
          } else {
            Write-Host "❌ Directory not found: $path"
          }
        }
        
        # Look for common VSTO output files
        Write-Host "=== Searching for VSTO files ==="
        Get-ChildItem -Recurse -Include "*.dll", "*.manifest", "*.vsto", "*.deploy" | ForEach-Object {
          $relativePath = $_.FullName.Substring((Get-Location).Path.Length + 1)
          $size = "$([math]::Round($_.Length / 1KB, 1)) KB"
          Write-Host "📄 $relativePath - $size"
        }


    - name: Sanitize Artifact Name
      id: sanitize_name
      run: |
        # Get the ref name and sanitize it for artifact naming
        $refName = "${{ github.ref_name || github.sha }}"
        Write-Host "Original ref name: $refName"
        
        # Remove invalid characters: " : < > | * ? \r \n \ /
        $sanitizedName = $refName -replace '[":/<>|*?\r\n\\]', '-'
        
        # Remove multiple consecutive dashes and trim
        $sanitizedName = $sanitizedName -replace '-+', '-'
        $sanitizedName = $sanitizedName.Trim('-')
        
        # Ensure it's not empty
        if ([string]::IsNullOrWhiteSpace($sanitizedName)) {
          $sanitizedName = "unknown"
        }
        
        $fullArtifactName = "VSTO-Addin-Package-$sanitizedName"
        
        Write-Host "Sanitized artifact name: $fullArtifactName"
        
        # Set output for use in subsequent steps
        echo "SANITIZED_NAME=$sanitizedName" >> $env:GITHUB_OUTPUT
        echo "FULL_ARTIFACT_NAME=$fullArtifactName" >> $env:GITHUB_OUTPUT

    - name: Upload published artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.sanitize_name.outputs.FULL_ARTIFACT_NAME }}
        path: ForensicWhisperDeskZH\publish
      id: upload_artifact

    - name: Download Artifact for Release
      if: github.ref == 'refs/heads/main'
      uses: actions/download-artifact@v4
      with:
        name: ${{ steps.sanitize_name.outputs.FULL_ARTIFACT_NAME }}
        path: ./release-artifacts

    - name: Extract Assembly Version
      id: extract_version
      run: |
        Write-Host "Extracting assembly version from AssemblyInfo.cs..."
        
        # Read the AssemblyInfo.cs file
        $assemblyInfoPath = "ForensicWhisperDeskZH\Properties\AssemblyInfo.cs"
        $content = Get-Content $assemblyInfoPath -Raw
        
        # Extract AssemblyVersion using regex
        if ($content -match '\[assembly:\s*AssemblyVersion\("([^"]+)"\)\]') {
          $assemblyVersion = $matches[1]
          Write-Host "Found AssemblyVersion: $assemblyVersion"
        } else {
          Write-Error "Could not find AssemblyVersion in $assemblyInfoPath"
          exit 1
        }
        
        # Create a tag-friendly version (prefix with 'v')
        $tagVersion = "v$assemblyVersion"
        Write-Host "Tag version will be: $tagVersion"
        
        # Set outputs for use in subsequent steps
        echo "ASSEMBLY_VERSION=$assemblyVersion" >> $env:GITHUB_OUTPUT
        echo "TAG_VERSION=$tagVersion" >> $env:GITHUB_OUTPUT

    - name: Create Release
      if: github.ref == 'refs/heads/main'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.extract_version.outputs.TAG_VERSION }}
        release_name: Release ${{ steps.extract_version.outputs.TAG_VERSION }}
        body: |
          ## ForensicWhisperDeskZH Release ${{ steps.extract_version.outputs.TAG_VERSION }}
          
          **Important**: This package is split into multiple parts due to size limitations.

          ### Features
          - VSTO Add-in for Microsoft Word
          - Whisper-based transcription capabilities
          - Assembly Version: ${{ steps.extract_version.outputs.ASSEMBLY_VERSION }}
          - GitVersion: ${{ steps.gitversion.outputs.semVer }}
          
          ### Installation Options
          
          **Quick Install (Recommended):**
          - 1. **Download ALL parts** (VSTO-Addin-Package-${{ steps.extract_version.outputs.TAG_VERSION }}.zip.001, .002, etc.)
          - 2. **Extract using 7-Zip** - right-click the .001 file and extract
          - 3. **Run `setup.exe`** from the extracted files **as Administrator**

          ### Key Points for Users:
          1. **Download ALL parts** - The split archive won't work unless all parts are present
          2. **Extract from the first part** - Always right-click on `.001` file to extract
          3. **Use proper extraction tools** - 7-Zip, WinRAR, or similar tools that support split archives
          4. **Windows built-in extractor won't work** with split archives
          
          ### System Requirements
          - Microsoft Word 2016 or later
          - .NET Framework 4.8
          - Windows 10 or later
        draft: false
        prerelease: false
      id: create_release

    - name: Create ZIP from Artifact Contents (Split)
      if: github.ref == 'refs/heads/main'
      run: |
        Write-Host "Creating split ZIP from artifact contents..."
        $zipBaseName = "VSTO-Addin-Package-${{ steps.extract_version.outputs.TAG_VERSION }}"
        
        # Use 7-Zip to create split archives (500MB parts)
        if (Get-Command "7z" -ErrorAction SilentlyContinue) {
          Write-Host "Using 7-Zip for split compression..."
          & 7z a -tzip "$zipBaseName.zip" ".\release-artifacts\*" -r -v1000m
        } else {
          # Install 7-Zip via chocolatey for splitting capability
          Write-Host "Installing 7-Zip..."
          choco install 7zip -y
          & "C:\Program Files\7-Zip\7z.exe" a -tzip "$zipBaseName.zip" ".\release-artifacts\*" -r -v500m
        }
        
        # List created files
        Get-ChildItem -Filter "$zipBaseName.zip*" | ForEach-Object {
          $size = [math]::Round($_.Length / 1MB, 2)
          Write-Host "✅ Created $($_.Name) ($size MB)"
        }

    - name: Upload Split Package Parts
      if: github.ref == 'refs/heads/main'
      run: |
        $tagVersion = "${{ steps.extract_version.outputs.TAG_VERSION }}"
        $parts = Get-ChildItem -Filter "VSTO-Addin-Package-$tagVersion.zip*"
        foreach ($part in $parts) {
          Write-Host "Uploading $($part.Name)..."
          
          $headers = @{
            'Authorization' = 'token ${{ secrets.GITHUB_TOKEN }}'
            'Content-Type' = 'application/zip'
          }
          
          $uploadUrl = "${{ steps.create_release.outputs.upload_url }}".Replace('{?name,label}', "?name=$($part.Name)")
          
          try {
            Invoke-RestMethod -Uri $uploadUrl -Method Post -Headers $headers -InFile $part.FullName
            Write-Host "✅ Successfully uploaded $($part.Name)"
          } catch {
            Write-Error "❌ Failed to upload $($part.Name): $($_.Exception.Message)"
          }
        }
